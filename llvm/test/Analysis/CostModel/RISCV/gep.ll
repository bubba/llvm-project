; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: sed s/DATALAYOUT/p:32:32/ %s | opt -mtriple=riscv32 -mattr=+v \
; RUN:   -passes="print<cost-model>" 2>&1 -disable-output | FileCheck %s \
; RUN:   -check-prefixes=RVI,RVI32
; RUN: sed s/DATALAYOUT/p:64:64/ %s | opt -mtriple=riscv64 -mattr=+v \
; RUN:   -passes="print<cost-model>" 2>&1 -disable-output | FileCheck %s \
; RUN:   -check-prefixes=RVI,RVI64

target datalayout = "DATALAYOUT"

define void @testi8(ptr %a, i32 %i) {
; RVI-LABEL: 'testi8'
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a1 = getelementptr inbounds i8, ptr %a, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %a1, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a2 = getelementptr inbounds i8, ptr %a, i32 -1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %a2, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a3 = getelementptr inbounds i8, ptr %a, i32 2047
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %a3, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a4 = getelementptr inbounds i8, ptr %a, i32 2048
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %a4, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a5 = getelementptr inbounds i8, ptr %a, i32 -2048
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %a5, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a6 = getelementptr inbounds i8, ptr %a, i32 -2049
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %a6, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %ai = getelementptr inbounds i8, ptr %a, i32 %i
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %ai, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %a1 = getelementptr inbounds i8, ptr %a, i32 1
  store volatile i8 0, ptr %a1
  %a2 = getelementptr inbounds i8, ptr %a, i32 -1
  store volatile i8 0, ptr %a2
  %a3 = getelementptr inbounds i8, ptr %a, i32 2047
  store volatile i8 0, ptr %a3
  %a4 = getelementptr inbounds i8, ptr %a, i32 2048
  store volatile i8 0, ptr %a4
  %a5 = getelementptr inbounds i8, ptr %a, i32 -2048
  store volatile i8 0, ptr %a5
  %a6 = getelementptr inbounds i8, ptr %a, i32 -2049
  store volatile i8 0, ptr %a6
  %ai = getelementptr inbounds i8, ptr %a, i32 %i
  store volatile i8 0, ptr %ai
  ret void
}

define void @testi16(ptr %a, i32 %i) {
; RVI-LABEL: 'testi16'
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a1 = getelementptr inbounds i16, ptr %a, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %a1, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a2 = getelementptr inbounds i16, ptr %a, i32 -1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %a2, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a3 = getelementptr inbounds i16, ptr %a, i32 1023
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %a3, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a4 = getelementptr inbounds i16, ptr %a, i32 1024
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %a4, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a5 = getelementptr inbounds i16, ptr %a, i32 -1024
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %a5, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a6 = getelementptr inbounds i16, ptr %a, i32 -1025
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %a6, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %ai = getelementptr inbounds i16, ptr %a, i32 %i
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %ai, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %a1 = getelementptr inbounds i16, ptr %a, i32 1
  store volatile i16 0, ptr %a1
  %a2 = getelementptr inbounds i16, ptr %a, i32 -1
  store volatile i16 0, ptr %a2
  %a3 = getelementptr inbounds i16, ptr %a, i32 1023
  store volatile i16 0, ptr %a3
  %a4 = getelementptr inbounds i16, ptr %a, i32 1024
  store volatile i16 0, ptr %a4
  %a5 = getelementptr inbounds i16, ptr %a, i32 -1024
  store volatile i16 0, ptr %a5
  %a6 = getelementptr inbounds i16, ptr %a, i32 -1025
  store volatile i16 0, ptr %a6
  %ai = getelementptr inbounds i16, ptr %a, i32 %i
  store volatile i16 0, ptr %ai
  ret void
}

define void @testi32(ptr %a, i32 %i) {
; RVI-LABEL: 'testi32'
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a1 = getelementptr inbounds i32, ptr %a, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %a1, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a2 = getelementptr inbounds i32, ptr %a, i32 -1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %a2, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a3 = getelementptr inbounds i32, ptr %a, i32 511
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %a3, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a4 = getelementptr inbounds i32, ptr %a, i32 512
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %a4, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a5 = getelementptr inbounds i32, ptr %a, i32 -512
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %a5, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a6 = getelementptr inbounds i32, ptr %a, i32 -513
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %a6, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %ai = getelementptr inbounds i32, ptr %a, i32 %i
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %ai, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %a1 = getelementptr inbounds i32, ptr %a, i32 1
  store volatile i32 0, ptr %a1
  %a2 = getelementptr inbounds i32, ptr %a, i32 -1
  store volatile i32 0, ptr %a2
  %a3 = getelementptr inbounds i32, ptr %a, i32 511
  store volatile i32 0, ptr %a3
  %a4 = getelementptr inbounds i32, ptr %a, i32 512
  store volatile i32 0, ptr %a4
  %a5 = getelementptr inbounds i32, ptr %a, i32 -512
  store volatile i32 0, ptr %a5
  %a6 = getelementptr inbounds i32, ptr %a, i32 -513
  store volatile i32 0, ptr %a6
  %ai = getelementptr inbounds i32, ptr %a, i32 %i
  store volatile i32 0, ptr %ai
  ret void
}

define void @testi64(ptr %a, i32 %i) {
; RVI32-LABEL: 'testi64'
; RVI32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a1 = getelementptr inbounds i64, ptr %a, i32 1
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile i64 0, ptr %a1, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a2 = getelementptr inbounds i64, ptr %a, i32 -1
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile i64 0, ptr %a2, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a3 = getelementptr inbounds i64, ptr %a, i32 255
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile i64 0, ptr %a3, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a4 = getelementptr inbounds i64, ptr %a, i32 256
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile i64 0, ptr %a4, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a5 = getelementptr inbounds i64, ptr %a, i32 -256
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile i64 0, ptr %a5, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a6 = getelementptr inbounds i64, ptr %a, i32 -257
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile i64 0, ptr %a6, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %ai = getelementptr inbounds i64, ptr %a, i32 %i
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile i64 0, ptr %ai, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
; RVI64-LABEL: 'testi64'
; RVI64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a1 = getelementptr inbounds i64, ptr %a, i32 1
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i64 0, ptr %a1, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a2 = getelementptr inbounds i64, ptr %a, i32 -1
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i64 0, ptr %a2, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a3 = getelementptr inbounds i64, ptr %a, i32 255
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i64 0, ptr %a3, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a4 = getelementptr inbounds i64, ptr %a, i32 256
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i64 0, ptr %a4, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a5 = getelementptr inbounds i64, ptr %a, i32 -256
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i64 0, ptr %a5, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a6 = getelementptr inbounds i64, ptr %a, i32 -257
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i64 0, ptr %a6, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %ai = getelementptr inbounds i64, ptr %a, i32 %i
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i64 0, ptr %ai, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %a1 = getelementptr inbounds i64, ptr %a, i32 1
  store volatile i64 0, ptr %a1
  %a2 = getelementptr inbounds i64, ptr %a, i32 -1
  store volatile i64 0, ptr %a2
  %a3 = getelementptr inbounds i64, ptr %a, i32 255
  store volatile i64 0, ptr %a3
  %a4 = getelementptr inbounds i64, ptr %a, i32 256
  store volatile i64 0, ptr %a4
  %a5 = getelementptr inbounds i64, ptr %a, i32 -256
  store volatile i64 0, ptr %a5
  %a6 = getelementptr inbounds i64, ptr %a, i32 -257
  store volatile i64 0, ptr %a6
  %ai = getelementptr inbounds i64, ptr %a, i32 %i
  store volatile i64 0, ptr %ai
  ret void
}

define void @testfloat(ptr %a, i32 %i) {
; RVI-LABEL: 'testfloat'
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a1 = getelementptr inbounds float, ptr %a, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile float 0.000000e+00, ptr %a1, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a2 = getelementptr inbounds float, ptr %a, i32 -1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile float 0.000000e+00, ptr %a2, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a3 = getelementptr inbounds float, ptr %a, i32 511
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile float 0.000000e+00, ptr %a3, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a4 = getelementptr inbounds float, ptr %a, i32 512
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile float 0.000000e+00, ptr %a4, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a5 = getelementptr inbounds float, ptr %a, i32 -512
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile float 0.000000e+00, ptr %a5, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a6 = getelementptr inbounds float, ptr %a, i32 -513
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile float 0.000000e+00, ptr %a6, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %ai = getelementptr inbounds float, ptr %a, i32 %i
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile float 0.000000e+00, ptr %ai, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %a1 = getelementptr inbounds float, ptr %a, i32 1
  store volatile float 0., ptr %a1
  %a2 = getelementptr inbounds float, ptr %a, i32 -1
  store volatile float 0., ptr %a2
  %a3 = getelementptr inbounds float, ptr %a, i32 511
  store volatile float 0., ptr %a3
  %a4 = getelementptr inbounds float, ptr %a, i32 512
  store volatile float 0., ptr %a4
  %a5 = getelementptr inbounds float, ptr %a, i32 -512
  store volatile float 0., ptr %a5
  %a6 = getelementptr inbounds float, ptr %a, i32 -513
  store volatile float 0., ptr %a6
  %ai = getelementptr inbounds float, ptr %a, i32 %i
  store volatile float 0., ptr %ai
  ret void
}

define void @testdouble(ptr %a, i32 %i) {
; RVI-LABEL: 'testdouble'
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a1 = getelementptr inbounds double, ptr %a, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile double 0.000000e+00, ptr %a1, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a2 = getelementptr inbounds double, ptr %a, i32 -1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile double 0.000000e+00, ptr %a2, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a3 = getelementptr inbounds double, ptr %a, i32 255
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile double 0.000000e+00, ptr %a3, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a4 = getelementptr inbounds double, ptr %a, i32 256
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile double 0.000000e+00, ptr %a4, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %a5 = getelementptr inbounds double, ptr %a, i32 -256
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile double 0.000000e+00, ptr %a5, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %a6 = getelementptr inbounds double, ptr %a, i32 -257
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile double 0.000000e+00, ptr %a6, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %ai = getelementptr inbounds double, ptr %a, i32 %i
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile double 0.000000e+00, ptr %ai, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %a1 = getelementptr inbounds double, ptr %a, i32 1
  store volatile double 0., ptr %a1
  %a2 = getelementptr inbounds double, ptr %a, i32 -1
  store volatile double 0., ptr %a2
  %a3 = getelementptr inbounds double, ptr %a, i32 255
  store volatile double 0., ptr %a3
  %a4 = getelementptr inbounds double, ptr %a, i32 256
  store volatile double 0., ptr %a4
  %a5 = getelementptr inbounds double, ptr %a, i32 -256
  store volatile double 0., ptr %a5
  %a6 = getelementptr inbounds double, ptr %a, i32 -257
  store volatile double 0., ptr %a6
  %ai = getelementptr inbounds double, ptr %a, i32 %i
  store volatile double 0., ptr %ai
  ret void
}

define void @testvecs(i32 %i) {
; RVI-LABEL: 'testvecs'
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %b0 = getelementptr inbounds <4 x i8>, ptr undef, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <4 x i8> undef, ptr %b0, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %b1 = getelementptr inbounds <4 x i16>, ptr undef, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <4 x i16> undef, ptr %b1, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %b2 = getelementptr inbounds <4 x i32>, ptr undef, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <4 x i32> undef, ptr %b2, align 16
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %b3 = getelementptr inbounds <4 x i64>, ptr undef, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile <4 x i64> undef, ptr %b3, align 32
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %b4 = getelementptr inbounds <4 x float>, ptr undef, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <4 x float> undef, ptr %b4, align 16
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %b5 = getelementptr inbounds <4 x double>, ptr undef, i32 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile <4 x double> undef, ptr %b5, align 32
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %c1 = getelementptr inbounds <4 x i8>, ptr undef, i32 128
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <4 x i8> undef, ptr %c1, align 4
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %c2 = getelementptr inbounds <4 x i16>, ptr undef, i32 128
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <4 x i16> undef, ptr %c2, align 8
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %c3 = getelementptr inbounds <4 x i32>, ptr undef, i32 128
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <4 x i32> undef, ptr %c3, align 16
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %c4 = getelementptr inbounds <4 x i64>, ptr undef, i32 128
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile <4 x i64> undef, ptr %c4, align 32
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %c5 = getelementptr inbounds <4 x float>, ptr undef, i32 128
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <4 x float> undef, ptr %c5, align 16
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %c6 = getelementptr inbounds <4 x double>, ptr undef, i32 128
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile <4 x double> undef, ptr %c6, align 32
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %b0 = getelementptr inbounds <4 x i8>, ptr undef, i32 1
  store volatile <4 x i8> undef, ptr %b0
  %b1 = getelementptr inbounds <4 x i16>, ptr undef, i32 1
  store volatile <4 x i16> undef, ptr %b1
  %b2 = getelementptr inbounds <4 x i32>, ptr undef, i32 1
  store volatile <4 x i32> undef, ptr %b2
  %b3 = getelementptr inbounds <4 x i64>, ptr undef, i32 1
  store volatile <4 x i64> undef, ptr %b3
  %b4 = getelementptr inbounds <4 x float>, ptr undef, i32 1
  store volatile <4 x float> undef, ptr %b4
  %b5 = getelementptr inbounds <4 x double>, ptr undef, i32 1
  store volatile <4 x double> undef, ptr %b5

  %c1 = getelementptr inbounds <4 x i8>, ptr undef, i32 128
  store volatile <4 x i8> undef, ptr %c1
  %c2 = getelementptr inbounds <4 x i16>, ptr undef, i32 128
  store volatile <4 x i16> undef, ptr %c2
  %c3 = getelementptr inbounds <4 x i32>, ptr undef, i32 128
  store volatile <4 x i32> undef, ptr %c3
  %c4 = getelementptr inbounds <4 x i64>, ptr undef, i32 128
  store volatile <4 x i64> undef, ptr %c4
  %c5 = getelementptr inbounds <4 x float>, ptr undef, i32 128
  store volatile <4 x float> undef, ptr %c5
  %c6 = getelementptr inbounds <4 x double>, ptr undef, i32 128
  store volatile <4 x double> undef, ptr %c6

  ret void
}

; Ensure that memory operations of a different type than the pointer source type
; use the correct type to determine if folding is possible. These operations
; are on vector types so there should be a cost for the GEP as the offset cannot
; be folded into the instruction.
define void @non_foldable_vector_uses(ptr %base, <2 x ptr> %base.vec) {
; RVI-LABEL: 'non_foldable_vector_uses'
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %x1 = load volatile <2 x i8>, ptr %1, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %x2 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr %2, i32 1, <2 x i1> undef, <2 x i8> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = getelementptr i8, <2 x ptr> %base.vec, <2 x i32> <i32 42, i32 43>
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %x3 = call <2 x i8> @llvm.masked.gather.v2i8.v2p0(<2 x ptr> %3, i32 1, <2 x i1> undef, <2 x i8> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %x4 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %4, <2 x i1> undef, <2 x i8> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %x5 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %5, <2 x i1> undef, i32 undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %x6 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %6, i64 undef, <2 x i1> undef, i32 undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <2 x i8> undef, ptr %7, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> undef, ptr %8, i32 1, <2 x i1> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = getelementptr i8, <2 x ptr> %base.vec, <2 x i32> <i32 42, i32 43>
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: call void @llvm.masked.scatter.v2i8.v2p0(<2 x i8> undef, <2 x ptr> %9, i32 1, <2 x i1> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> undef, ptr %10, <2 x i1> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> undef, ptr %11, <2 x i1> undef, i32 undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> undef, ptr %12, i64 undef, <2 x i1> undef, i32 undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %1 = getelementptr i8, ptr %base, i32 42
  %x1 = load volatile <2 x i8>, ptr %1

  %2 = getelementptr i8, ptr %base, i32 42
  %x2 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr %2, i32 1, <2 x i1> undef, <2 x i8> undef)

  %3 = getelementptr i8, <2 x ptr> %base.vec, <2 x i32> <i32 42, i32 43>
  %x3 = call <2 x i8> @llvm.masked.gather.v2i8.v2p0(<2 x ptr> %3, i32 1, <2 x i1> undef, <2 x i8> undef)

  %4 = getelementptr i8, ptr %base, i32 42
  %x4 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %4, <2 x i1> undef, <2 x i8> undef)

  %5 = getelementptr i8, ptr %base, i32 42
  %x5 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %5, <2 x i1> undef, i32 undef)

  %6 = getelementptr i8, ptr %base, i32 42
  %x6 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.i64(ptr %6, i64 undef, <2 x i1> undef, i32 undef)

  %7 = getelementptr i8, ptr %base, i32 42
  store volatile <2 x i8> undef, ptr %7

  %8 = getelementptr i8, ptr %base, i32 42
  call void @llvm.masked.store.v2i8.p0(<2 x i8> undef, ptr %8, i32 1, <2 x i1> undef)

  %9 = getelementptr i8, <2 x ptr> %base.vec, <2 x i32> <i32 42, i32 43>
  call void @llvm.masked.scatter.v2i8.v2p0(<2 x i8> undef, <2 x ptr> %9, i32 1, <2 x i1> undef)

  %10 = getelementptr i8, ptr %base, i32 42
  call void @llvm.masked.compressstore.v2i8(<2 x i8> undef, ptr %10, <2 x i1> undef)

  %11 = getelementptr i8, ptr %base, i32 42
  call void @llvm.vp.store.v2i8.p0(<2 x i8> undef, ptr %11, <2 x i1> undef, i32 undef)

  %12 = getelementptr i8, ptr %base, i32 42
  call void @llvm.experimental.vp.strided.store.v2i8.i64(<2 x i8> undef, ptr %12, i64 undef, <2 x i1> undef, i32 undef)

  ret void
}

; Because there is no offset the GEP should be compltely foldable into the user.
define void @foldable_vector_uses(ptr %base, <2 x ptr> %base.vec) {
; RVI-LABEL: 'foldable_vector_uses'
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %1 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %x1 = load volatile <2 x i8>, ptr %1, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %2 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %x2 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr %2, i32 1, <2 x i1> undef, <2 x i8> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %3 = getelementptr i8, <2 x ptr> %base.vec, <2 x i32> zeroinitializer
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %x3 = call <2 x i8> @llvm.masked.gather.v2i8.v2p0(<2 x ptr> %3, i32 1, <2 x i1> undef, <2 x i8> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %4 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %x4 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %4, <2 x i1> undef, <2 x i8> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %5 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %x5 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %5, <2 x i1> undef, i32 undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %6 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %x6 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %6, i64 undef, <2 x i1> undef, i32 undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %7 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile <2 x i8> undef, ptr %7, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %8 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> undef, ptr %8, i32 1, <2 x i1> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %9 = getelementptr i8, <2 x ptr> %base.vec, <2 x i32> zeroinitializer
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: call void @llvm.masked.scatter.v2i8.v2p0(<2 x i8> undef, <2 x ptr> %9, i32 1, <2 x i1> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %10 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> undef, ptr %10, <2 x i1> undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %11 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> undef, ptr %11, <2 x i1> undef, i32 undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: %12 = getelementptr i8, ptr %base, i32 0
; RVI-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> undef, ptr %12, i64 undef, <2 x i1> undef, i32 undef)
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %1 = getelementptr i8, ptr %base, i32 0
  %x1 = load volatile <2 x i8>, ptr %1

  %2 = getelementptr i8, ptr %base, i32 0
  %x2 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr %2, i32 1, <2 x i1> undef, <2 x i8> undef)

  %3 = getelementptr i8, <2 x ptr> %base.vec, <2 x i32> <i32 0, i32 0>
  %x3 = call <2 x i8> @llvm.masked.gather.v2i8.v2p0(<2 x ptr> %3, i32 1, <2 x i1> undef, <2 x i8> undef)

  %4 = getelementptr i8, ptr %base, i32 0
  %x4 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %4, <2 x i1> undef, <2 x i8> undef)

  %5 = getelementptr i8, ptr %base, i32 0
  %x5 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %5, <2 x i1> undef, i32 undef)

  %6 = getelementptr i8, ptr %base, i32 0
  %x6 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.i64(ptr %6, i64 undef, <2 x i1> undef, i32 undef)

  %7 = getelementptr i8, ptr %base, i32 0
  store volatile <2 x i8> undef, ptr %7

  %8 = getelementptr i8, ptr %base, i32 0
  call void @llvm.masked.store.v2i8.p0(<2 x i8> undef, ptr %8, i32 1, <2 x i1> undef)

  %9 = getelementptr i8, <2 x ptr> %base.vec, <2 x i32> <i32 0, i32 0>
  call void @llvm.masked.scatter.v2i8.v2p0(<2 x i8> undef, <2 x ptr> %9, i32 1, <2 x i1> undef)

  %10 = getelementptr i8, ptr %base, i32 0
  call void @llvm.masked.compressstore.v2i8(<2 x i8> undef, ptr %10, <2 x i1> undef)

  %11 = getelementptr i8, ptr %base, i32 0
  call void @llvm.vp.store.v2i8.p0(<2 x i8> undef, ptr %11, <2 x i1> undef, i32 undef)

  %12 = getelementptr i8, ptr %base, i32 0
  call void @llvm.experimental.vp.strided.store.v2i8.i64(<2 x i8> undef, ptr %12, i64 undef, <2 x i1> undef, i32 undef)

  ret void
}

declare <2 x i8> @llvm.masked.load.v2i8.p0(ptr, i32, <2 x i1>, <2 x i8>)
declare <2 x i8> @llvm.masked.gather.v2i8.v2p0(<2 x ptr>, i32, <2 x i1>, <2 x i8>)
declare <2 x i8> @llvm.masked.expandload.v2i8(ptr, <2 x i1>, <2 x i8>)
declare <2 x i8> @llvm.vp.load.v2i8.p0(ptr, <2 x i1>, i32)
declare <2 x i8> @llvm.experimental.vp.strided.load.v2i8.i64(ptr, i64, <2 x i1>, i32)

declare void @llvm.masked.store.v2i8.p0(<2 x i8>, ptr, i32, <2 x i1>)
declare void @llvm.masked.scatter.v2i8.v2p0(<2 x i8>, <2 x ptr>, i32, <2 x i1>)
declare void @llvm.masked.compressstore.v2i8(<2 x i8>, ptr, <2 x i1>)
declare void @llvm.vp.store.v2i8.p0(<2 x i8>, ptr, <2 x i1>, i32)
declare void @llvm.experimental.vp.strided.store.v2i8.i64(<2 x i8>, ptr, i64, <2 x i1>, i32)

; Ensure that GEPs aren't folded if any of their uses aren't legal addressing
; modes
define <2 x i8> @fold_two_different_uses(ptr %base) {
; RVI-LABEL: 'fold_two_different_uses'
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = getelementptr i8, ptr %base, i32 42
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 2, ptr %1, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %x = load volatile <2 x i8>, ptr %1, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret <2 x i8> %x
;
  %1 = getelementptr i8, ptr %base, i32 42
  store volatile i8 2, ptr %1
  %x = load volatile <2 x i8>, ptr %1
  ret <2 x i8> %x
}

; The i8 GEP is the only GEP here that should have a cost of 1, because the
; others will require scaling (i.e. a slli)
define void @scale_baseoffset(ptr %base, i32 %offset) {
; RVI32-LABEL: 'scale_baseoffset'
; RVI32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = getelementptr i8, ptr %base, i32 %offset
; RVI32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %1, align 1
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %2 = getelementptr i16, ptr %base, i32 %offset
; RVI32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %2, align 2
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %3 = getelementptr i32, ptr %base, i32 %offset
; RVI32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %3, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = getelementptr i64, ptr %base, i32 %offset
; RVI32-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: store volatile i64 0, ptr %4, align 4
; RVI32-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
; RVI64-LABEL: 'scale_baseoffset'
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = getelementptr i8, ptr %base, i32 %offset
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %1, align 1
; RVI64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %2 = getelementptr i16, ptr %base, i32 %offset
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %2, align 2
; RVI64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %3 = getelementptr i32, ptr %base, i32 %offset
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i32 0, ptr %3, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %4 = getelementptr i64, ptr %base, i32 %offset
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i64 0, ptr %4, align 4
; RVI64-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %1 = getelementptr i8, ptr %base, i32 %offset
  store volatile i8 0, ptr %1
  %2 = getelementptr i16, ptr %base, i32 %offset
  store volatile i16 0, ptr %2
  %3 = getelementptr i32, ptr %base, i32 %offset
  store volatile i32 0, ptr %3
  %4 = getelementptr i64, ptr %base, i32 %offset
  store volatile i64 0, ptr %4

  ret void
}

@G = global i8 zeroinitializer

; This requires materializing a global address
;       lui     a0, %hi(G)
;       addi    a0, a0, %lo(G)
;       sh      zero, (a0)
define void @global_addr(ptr %base) {
; RVI-LABEL: 'global_addr'
; RVI-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %1 = getelementptr i8, ptr @G
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %1, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %1 = getelementptr i8, ptr @G
  store volatile i8 0, ptr %1

  ret void
}

; This requires materializing a global address and adding an (unknown) offset
;       lui     a0, %hi(G)
;       addi    a0, a0, %lo(G)
;       add     a0, a0, a1
;       sb      zero, (a0)
define void @global_offset(ptr %base, i32 %offset) {
; RVI-LABEL: 'global_offset'
; RVI-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %1 = getelementptr i8, ptr @G, i32 %offset
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i8 0, ptr %1, align 1
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %1 = getelementptr i8, ptr @G, i32 %offset
  store volatile i8 0, ptr %1

  ret void
}

; This requires all 3: materializing the global address, scaling the offset
; and adding the offset to the base.
;       slli    a1, a1, 3
;       lui     a0, %hi(G)
;       addi    a0, a0, %lo(G)
;       add     a0, a0, a1
;       sh      zero, 4(a0)
define void @global_offset_scale(ptr %base, i32 %offset) {
; RVI-LABEL: 'global_offset_scale'
; RVI-NEXT:  Cost Model: Found an estimated cost of 5 for instruction: %1 = getelementptr [4 x i16], ptr @G, i32 %offset, i32 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: store volatile i16 0, ptr %1, align 2
; RVI-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
  %1 = getelementptr [4 x i16], ptr @G, i32 %offset, i32 2
  store volatile i16 0, ptr %1

  ret void
}
